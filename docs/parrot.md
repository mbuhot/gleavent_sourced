# Parrot SQL Code Generation

This document covers how to use parrot (sqlc for Gleam) for type-safe SQL code generation, including our custom fork modifications.

## Overview

Parrot generates type-safe Gleam code from SQL queries using sqlc. It:
1. Reads SQL files with sqlc annotations
2. Connects to your database to validate queries and extract schema
3. Generates Gleam functions with proper types and decoders

## Our Custom Fork

We maintain a fork at `https://github.com/mbuhot/parrot` with these key changes:

### Built-in JSON Codegen
**Problem**: Original parrot used unstable WASM plugins that crashed on macOS.
**Solution**: Modified to use sqlc's built-in JSON codegen instead.

```yaml
# Original (problematic):
plugins:
  - name: jsonb
    wasm:
      url: https://github.com/daniellionel01/sqlc-gen-json/releases/download/v1.0.0/sqlc-gen-json.wasm
      sha256: ffbd8cfaecc971d8cdf145591eac28731ffb50b7348131868ce66cc0e3192b7e

# Our fork (stable):
gen:
  json:
    out: .
    indent: "  "
    filename: queries.json
```

### PostgreSQL 17 Compatibility
**Problem**: PostgreSQL 17's pg_dump outputs `\restrict` and `\unrestrict` commands that sqlc doesn't understand.
**Solution**: Use a custom pg_dump wrapper script that filters these commands.

## Setup

### Dependencies

```toml
parrot = { git = "https://github.com/mbuhot/parrot", ref = "a776acb" }
```

### Environment

```bash
DATABASE_URL="postgres://username:password@host:port/database"
```

### PostgreSQL 17 pg_dump Wrapper

The project includes `bin/pg_dump` wrapper script:
```bash
#!/bin/bash
REAL_PG_DUMP="/opt/homebrew/opt/postgresql@17/bin/pg_dump"
"$REAL_PG_DUMP" "$@" | grep -v '^\\restrict' | grep -v '^\\unrestrict'
```

And `bin/parrot` convenience script that automatically sets up the PATH:
```bash
#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export PATH="$SCRIPT_DIR:$PATH"
gleam run -m parrot "$@"
```

## Writing SQL Queries

### File Structure

Parrot scans for any directory named `sql` under `src/` and processes all `.sql` files within them. This supports bounded context organization:

```
src/
└── gleavent_sourced/
    ├── sql/
    │   └── events.sql           # Core event store operations
    ├── sql.gleam                # Generated by parrot (consolidated)
    ├── customer_support/
    │   └── sql/
    │       └── tickets.sql      # Domain-specific queries
    ├── billing/
    │   └── sql/
    │       └── invoices.sql     # Another bounded context
    └── analytics/
        └── sql/
            └── reports.sql      # Analytics queries
```

All SQL files are consolidated into a single `sql.gleam` file in your main project directory.

### Query Annotations

Use sqlc annotations to define query behavior:

```sql
-- name: AppendEvent :exec
INSERT INTO events (event_type, payload, metadata)
VALUES ($1, $2, $3);

-- name: ReadAllEvents :many
SELECT sequence_number, occurred_at, event_type, payload, metadata
FROM events
ORDER BY sequence_number;

-- name: GetEventById :one
SELECT sequence_number, occurred_at, event_type, payload, metadata
FROM events
WHERE sequence_number = $1;

-- name: CountEvents :one
SELECT COUNT(*) as total FROM events;
```

### Annotation Types

- `:exec` - INSERT/UPDATE/DELETE with no return value
- `:one` - SELECT returning exactly one row
- `:many` - SELECT returning multiple rows
- `:execrows` - Returns number of affected rows (not supported in our fork)

## Code Generation

### Running Parrot

```bash
./bin/parrot
```

This generates `src/your_project/sql.gleam` with type-safe functions.

### Generated Code Structure

For the SQL above, parrot generates:

```gleam
// Insert function (returns #(sql, params))
pub fn append_event(
  event_type event_type: String,
  payload payload: String,
  metadata metadata: String,
) {
  let sql = "INSERT INTO events (event_type, payload, metadata) VALUES ($1, $2, $3)"
  #(sql, [
    dev.ParamString(event_type),
    dev.ParamString(payload),
    dev.ParamString(metadata),
  ])
}

// Query functions (return #(sql, params, decoder))
pub type ReadAllEvents {
  ReadAllEvents(
    sequence_number: Int,
    occurred_at: Timestamp,
    event_type: String,
    payload: String,
    metadata: String,
  )
}

pub fn read_all_events() {
  let sql = "SELECT sequence_number, occurred_at, event_type, payload, metadata FROM events ORDER BY sequence_number"
  #(sql, [], read_all_events_decoder())
}

pub fn read_all_events_decoder() -> decode.Decoder(ReadAllEvents) {
  use sequence_number <- decode.field(0, decode.int)
  use occurred_at <- decode.field(1, dev.datetime_decoder())
  use event_type <- decode.field(2, decode.string)
  use payload <- decode.field(3, decode.string)
  use metadata <- decode.field(4, decode.string)
  decode.success(ReadAllEvents(
    sequence_number:,
    occurred_at:,
    event_type:,
    payload:,
    metadata:,
  ))
}
```

## JSONB Handling

PostgreSQL JSONB columns are mapped to `String` types because:
1. PostgreSQL protocol sends/receives JSONB as JSON strings
2. This matches pog's expected usage: `pog.text(json.to_string(my_json))`

```gleam
// Storing JSON
let payload = json.object([
  #("message", json.string("Hello")),
  #("count", json.int(42))
])
let payload_str = json.to_string(payload)

// Generated function expects String
let #(sql, params) = sql.append_event("test_event", payload_str, "{}")
```

## Integration with Pog

### Parameter Conversion

Generated parrot parameters need conversion to pog values:

```gleam
// Create conversion utility
import parrot/dev
import pog

pub fn parrot_to_pog(param: dev.Param) -> pog.Value {
  case param {
    dev.ParamString(x) -> pog.text(x)
    dev.ParamInt(x) -> pog.int(x)
    dev.ParamFloat(x) -> pog.float(x)
    dev.ParamBool(x) -> pog.bool(x)
    dev.ParamBitArray(x) -> pog.bytea(x)
    dev.ParamList(x) -> pog.array(parrot_to_pog, x)
    dev.ParamTimestamp(x) -> pog.timestamp(x)
    dev.ParamDynamic(_) -> panic as "ParamDynamic not supported"
  }
}

pub fn add_parrot_params(query: pog.Query(t), params: List(dev.Param)) -> pog.Query(t) {
  list.fold(params, query, fn(q, param) {
    pog.parameter(q, parrot_to_pog(param))
  })
}
```

### Query Execution

```gleam
// Insert query
let #(insert_sql, insert_params) = sql.append_event(event_type, payload, metadata)
let insert_query = 
  pog.query(insert_sql)
  |> add_parrot_params(insert_params)
let assert Ok(_) = pog.execute(insert_query, on: db)

// Select query  
let #(select_sql, _select_params, _decoder) = sql.read_all_events()
let select_query =
  pog.query(select_sql)
  |> pog.returning(sql.read_all_events_decoder())
let assert Ok(returned) = pog.execute(select_query, on: db)
let events = returned.rows
```

## Type Mappings

Parrot maps PostgreSQL types to Gleam types:

| PostgreSQL | Gleam | Pog Value |
|------------|-------|-----------|
| TEXT, VARCHAR | String | `pog.text()` |
| INTEGER, BIGINT | Int | `pog.int()` |
| REAL, NUMERIC | Float | `pog.float()` |
| BOOLEAN | Bool | `pog.bool()` |
| BYTEA | BitArray | `pog.bytea()` |
| TIMESTAMPTZ | Timestamp | `pog.timestamp()` |
| JSONB | String | `pog.text()` |
| Arrays | List(T) | `pog.array()` |

## Configuration

The generated `sqlc.yaml` automatically includes all discovered SQL files:

```yaml
version: "2"
sql:
  - schema: schema.sql
    queries: [
      "../../src/gleavent_sourced/sql/events.sql",
      "../../src/gleavent_sourced/customer_support/sql/tickets.sql", 
      "../../src/gleavent_sourced/billing/sql/invoices.sql"
    ]
    engine: postgresql
    gen:
      json:
        out: .
        indent: "  "
        filename: queries.json
```

## Troubleshooting

### "DATABASE_URL environment variable not set"
Set `DATABASE_URL` environment variable before running parrot.

### "pg_dump error"
Ensure pg_dump version matches PostgreSQL server version, or use our wrapper script.

### "sqlc generate failed"
Check that:
1. SQL syntax is valid
2. Tables exist in database
3. sqlc annotations are correct
4. Schema is up to date

### "ParamDynamic not supported"
Our conversion utility doesn't handle dynamic parameters. Use specific typed parameters instead.

## Bounded Context Integration

### Automatic Discovery
Parrot automatically discovers SQL files by walking the `src/` directory tree and finding any directory named `sql`. This enables bounded context organization where each domain can maintain its own SQL queries.

### Consolidated Output
All SQL functions from all bounded contexts are generated into a single `src/your_project/sql.gleam` file, providing type-safe access across the entire application:

```gleam
// From gleavent_sourced/sql/events.sql
pub fn append_event(...)
pub fn read_all_events()

// From gleavent_sourced/customer_support/sql/tickets.sql  
pub fn read_events_for_ticket_command_context(...)

// From gleavent_sourced/billing/sql/invoices.sql
pub fn read_billing_events_for_customer(...)
```

### Query Name Uniqueness
Ensure query names are unique across all bounded contexts to avoid conflicts in the generated code.

## Best Practices

1. **Run migrations first** - parrot needs current schema
2. **Use descriptive query names** - they become function names and must be unique across all contexts
3. **Organize by domain** - use bounded context directories with their own `sql/` folders
4. **Group related queries** in same SQL file within each context
5. **Test generated code** - verify queries work as expected
6. **Handle JSONB as strings** - don't try to use Dynamic types
7. **Keep SQL simple** - complex queries may not generate clean types
8. **Use transactions** for multi-query operations
9. **Version pin the fork** - use specific commit refs for reproducibility

This covers the essential patterns for using our parrot fork effectively.