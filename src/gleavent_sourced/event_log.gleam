import gleam/dict
import gleam/dynamic.{type Dynamic}
import gleam/dynamic/decode
import gleam/json
import gleam/list
import gleam/result

import gleam/erlang/process
import gleavent_sourced/event_filter.{type EventFilter}
import gleavent_sourced/parrot_pog
import gleavent_sourced/sql
import pog

/// Custom error type for query operations that can fail at database or mapping level
pub type QueryError {
  DatabaseError(pog.QueryError)
  JsonParseError(json.DecodeError)
  MappingError(String)
}

// Event type for reading events from the database
// sequence_number is auto-generated by PostgreSQL
pub type Event {
  Event(
    sequence_number: Int,
    occurred_at: String,
    event_type: String,
    payload: dynamic.Dynamic,
    metadata: dict.Dict(String, String),
  )
}

pub fn connect(pool_name: process.Name(pog.Message)) -> pog.Connection {
  pog.named_connection(pool_name)
}

pub fn append_events(
  db: pog.Connection,
  events: List(event_type),
  event_converter: fn(event_type) -> #(String, json.Json),
  metadata: String,
) -> Result(Nil, pog.QueryError) {
  list.try_each(events, fn(event) {
    let #(event_type, payload_json) = event_converter(event)
    let payload = json.to_string(payload_json)

    let #(insert_sql, insert_params) =
      sql.append_event(
        event_type: event_type,
        payload: payload,
        metadata: metadata,
      )

    let insert_query =
      pog.query(insert_sql)
      |> parrot_pog.parameters(insert_params)

    pog.execute(insert_query, on: db)
    |> result.map(fn(_) { Nil })
  })
}

/// Query events using EventFilter with typed result mapping
pub fn query_events(
  db: pog.Connection,
  filter: EventFilter,
  event_mapper: fn(String, Dynamic) -> Result(event_type, String),
) -> Result(#(List(event_type), Int), QueryError) {
  let filters_json = event_filter.to_string(filter)

  let #(select_sql, select_params, _decoder) =
    sql.read_events_with_filter(filters: filters_json)

  let select_query =
    pog.query(select_sql)
    |> parrot_pog.parameters(select_params)
    |> pog.returning(sql.read_events_with_filter_decoder())

  case pog.execute(select_query, on: db) {
    Ok(returned) -> {
      let raw_rows = returned.rows

      // Get max sequence number (all rows have the same value)
      let max_sequence = case raw_rows {
        [] -> 0
        [first, ..] -> first.current_max_sequence
      }

      // Map events using the provided mapper
      let mapped_events =
        list.try_map(raw_rows, fn(row) {
          case json.parse(row.payload, decode.dynamic) {
            Ok(payload_dynamic) ->
              case event_mapper(row.event_type, payload_dynamic) {
                Ok(event) -> Ok(event)
                Error(msg) -> Error(MappingError(msg))
              }
            Error(err) -> Error(JsonParseError(err))
          }
        })

      case mapped_events {
        Ok(events) -> Ok(#(events, max_sequence))
        Error(err) -> Error(err)
      }
    }
    Error(err) -> Error(DatabaseError(err))
  }
}
